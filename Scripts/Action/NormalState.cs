//------------------------------------------------------------------------------
// <auto-generated>
//     このコードはツールによって生成されました。
//     ランタイム バージョン:4.0.30319.34209
//
//     このファイルへの変更は、以下の状況下で不正な動作の原因になったり、
//     コードが再生成されるときに損失したりします。
// </auto-generated>
//------------------------------------------------------------------------------
using System.Collections;
using UnityEngine;
using UnityEngine.UI;

namespace GraduationProject
{
	public class NormalState : ArtificialIntelligenceStage
	{
		private float WAIT_TIME = 1.0f;
		private float ACTIVE_RANGE = 5.0f;
		private float WALK_RANGE = 5.0f;
		private float WAIN_RANGE = 2.0f;

		private enum ActionPattern
		{
			LOOK,
			WALK_LEFT,
			WALK_RIGHT,
			WALK_FRONT,
			WALK_BACK,
			ATTACK,
		};		
		private ActionPattern enemyAction;

		public NormalState ()
		{
			enemyAction = ActionPattern.LOOK;
			nextState = this;
		}

		public NormalState (EnemyInformation Info) : base (Info)
		{
			enemyAction = ActionPattern.LOOK;
			nextState = this;
			enemyInfo.animator.SetFloat ("speed", 0f);
			enemyInfo.animator.Play ("Idle");
			targetPosition = enemyInfo.transform.position;
		}

		public override Vector3 Run ()
		{
			Vector3 moveDirection = Vector3.zero;
			
			UseGravity ();
			
			float distance = (targetPosition - enemyInfo.transform.position).magnitude;
			if (distance > WAIN_RANGE)
			{
				Vector3 direction = (targetPosition - enemyInfo.transform.position).normalized;
				direction.y = 0f;
				direction = direction.normalized;
				
				if (direction != Vector3.zero) enemyInfo.transform.rotation = Quaternion.LookRotation (direction);
				moveDirection = direction;
				speed = distance > WALK_RANGE ? WALK_RANGE : WALK_RANGE/3f;
				enemyInfo.animator.SetFloat ("speed", distance > WALK_RANGE ? 1f : 0.5f);
				timeCounter = Time.time;
			}
			else
			{
				targetPosition = enemyInfo.transform.position;
				moveDirection = Action ();
			}
			
			moveDirection = moveDirection*speed + new Vector3 (0f, velocity, 0f);
			
			if (enemyInfo.pushForce_z > 0f)
			{
				enemyInfo.pushForce_z -= 0.4f;
				moveDirection = enemyInfo.pushDirection*enemyInfo.pushForce_z + new Vector3 (0f, velocity, 0f);
			}
			
			return moveDirection;
		}

		private Vector3 Action ()
		{
			Vector3 lookVector = (enemyInfo.player.transform.position - enemyInfo.transform.position).normalized;
			lookVector.y = 0;
			enemyInfo.transform.rotation = Quaternion.LookRotation (lookVector);
			Vector3 moveDirection = Vector3.zero;
			
			float dis = (enemyInfo.player.transform.position - enemyInfo.transform.position).magnitude;
			switch (enemyAction)
			{
			case	ActionPattern.LOOK:
				enemyInfo.animator.SetFloat ("speed", 0);
				if (dis > ACTIVE_RANGE) return Vector3.zero;
				
				if (Time.time - timeCounter > WAIT_TIME)
				{
					if (dis > WAIN_RANGE*2f)
					{
						int rand = Random.Range (1, 10);
						if (rand > 8)
						{
							enemyAction = ActionPattern.WALK_LEFT;
						}
						
						timeCounter = Time.time;
					}
					else
					{
						int rand = Random.Range (1, 10);

						if (rand > 3)
						{
							enemyAction = ActionPattern.WALK_LEFT;
						}
						else
						{
							if (dis < enemyInfo.range)
							{
								enemyAction = ActionPattern.ATTACK;
								enemyInfo.animator.CrossFade ("Attack", 0.1f);
							}
							else
							{
								enemyAction = ActionPattern.WALK_FRONT;
							}
						}
						
						timeCounter = Time.time;
					}
				}
				break;
				
			case	ActionPattern.ATTACK:
				if (Time.time - timeCounter > WAIT_TIME)
				{
					enemyAction = ActionPattern.LOOK;
					timeCounter = Time.time+WAIT_TIME*2f;
				}
				break;
				
			case	ActionPattern.WALK_LEFT:
				moveDirection = enemyInfo.transform.TransformDirection (Vector3.left);
				moveDirection.y = 0f;
				moveDirection = moveDirection.normalized;
				
				speed = enemyInfo.moveSpeed/2f;
				enemyInfo.animator.SetFloat ("speed", 0.5f);
				if (Time.time - timeCounter > WAIT_TIME/3 + Random.Range (0.1f, 0.5f))
				{
					if (GetDistance () > WAIN_RANGE)
					{
						enemyAction = ActionPattern.WALK_RIGHT;
						timeCounter = Time.time;
					}
					else
					{
						int rand = Random.Range (0, 10);
						
						if (rand > 5)
							enemyAction = ActionPattern.WALK_RIGHT;
						else
							enemyAction = ActionPattern.LOOK;
						
						timeCounter = Time.time;
					}
				}
				break;
				
			case	ActionPattern.WALK_RIGHT:
				moveDirection = enemyInfo.transform.TransformDirection (Vector3.right);
				moveDirection.y = 0f;
				moveDirection = moveDirection.normalized;
				
				speed = enemyInfo.moveSpeed/2f;
				enemyInfo.animator.SetFloat ("speed", 0.5f);
				if (Time.time - timeCounter > WAIT_TIME/3 + Random.Range (0.1f, 0.5f))
				{
					enemyAction = ActionPattern.LOOK;
					timeCounter = Time.time + WAIT_TIME;
				}
				break;
				
			case	ActionPattern.WALK_FRONT:
				moveDirection = enemyInfo.transform.TransformDirection (Vector3.forward);
				moveDirection.y = 0f;
				moveDirection = moveDirection.normalized;
				
				speed = enemyInfo.moveSpeed/2f;
				enemyInfo.animator.SetFloat ("speed", 0.5f);
				if (Time.time - timeCounter > WAIT_TIME/2 + Random.Range (0.1f, 0.5f))
				{
					int rand = Random.Range (0, 10);
					
					if (rand > 6)
						enemyAction = ActionPattern.LOOK;
					else
						enemyAction = ActionPattern.WALK_BACK;
					timeCounter = Time.time;
				}
				break;
				
			case	ActionPattern.WALK_BACK:
				moveDirection = enemyInfo.transform.TransformDirection (Vector3.back);
				moveDirection.y = 0f;
				moveDirection = moveDirection.normalized;
				
				speed = enemyInfo.moveSpeed/2f;
				enemyInfo.animator.SetFloat ("speed", 0.5f);
				if (Time.time - timeCounter > WAIT_TIME/3 + Random.Range (0.1f, 0.5f))
				{
					enemyAction = ActionPattern.LOOK;
					timeCounter = Time.time;
				}
				break;
			}
			
			return moveDirection;
		}

		public override void StateEvent ()
		{
			if (enemyInfo.transform.InverseTransformPoint (enemyInfo.player.transform.position).z > 0f && GetDistance ()<enemyInfo.range)
			{
				enemyInfo.player.Damage (enemyInfo.attack, enemyInfo.transform.position);
			}
		}
	}
}

